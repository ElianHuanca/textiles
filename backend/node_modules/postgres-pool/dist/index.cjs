'use strict';

const events = require('events');
const fs = require('fs');
const path = require('path');
const promises = require('timers/promises');
const pg = require('pg');
const uuid = require('uuid');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const fs__namespace = /*#__PURE__*/_interopNamespaceCompat(fs);
const path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);
const pg__default = /*#__PURE__*/_interopDefaultCompat(pg);

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PostgresPoolError extends Error {
  constructor(message, code) {
    super(message);
    __publicField$1(this, "code");
    this.name = "PostgresPoolError";
    this.code = code;
    Object.setPrototypeOf(this, PostgresPoolError.prototype);
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Pool extends events.EventEmitter {
  constructor(options) {
    super();
    __publicField(this, "options");
    // Internal event emitter used to handle queued connection requests
    __publicField(this, "connectionQueueEventEmitter");
    __publicField(this, "connections", []);
    // Should self order by idle timeout ascending
    __publicField(this, "idleConnections", []);
    __publicField(this, "connectionQueue", []);
    __publicField(this, "isEnding", false);
    const defaultOptions = {
      poolSize: 10,
      idleTimeoutMillis: 1e4,
      waitForAvailableConnectionTimeoutMillis: 9e4,
      connectionTimeoutMillis: 5e3,
      retryConnectionMaxRetries: 5,
      retryConnectionWaitMillis: 100,
      retryConnectionErrorCodes: ["ENOTFOUND", "EAI_AGAIN", "ERR_PG_CONNECT_TIMEOUT", "timeout expired"],
      reconnectOnDatabaseIsStartingError: true,
      waitForDatabaseStartupMillis: 0,
      databaseStartupTimeoutMillis: 9e4,
      reconnectOnReadOnlyTransactionError: true,
      waitForReconnectReadOnlyTransactionMillis: 0,
      readOnlyTransactionReconnectTimeoutMillis: 9e4,
      reconnectOnConnectionError: true,
      waitForReconnectConnectionMillis: 0,
      connectionReconnectTimeoutMillis: 9e4,
      namedParameterFindRegExp: /@(\w)+\b/g,
      getNamedParameterReplaceRegExp(namedParameter) {
        return new RegExp(`@${namedParameter}\\b`, "gm");
      },
      getNamedParameterName(namedParameterWithSymbols) {
        return namedParameterWithSymbols.substring(1);
      }
    };
    const { ssl, ...otherOptions } = options;
    this.options = { ...defaultOptions, ...otherOptions };
    if (ssl === "aws-rds") {
      this.options.ssl = {
        rejectUnauthorized: true,
        ca: fs__namespace.readFileSync(path__namespace.join(__dirname, "./certs/rds-global-bundle.pem")),
        minVersion: "TLSv1.2"
      };
    } else {
      this.options.ssl = ssl;
    }
    this.connectionQueueEventEmitter = new events.EventEmitter();
  }
  /**
   * Gets the number of queued requests waiting for a database connection
   */
  get waitingCount() {
    return this.connectionQueue.length;
  }
  /**
   * Gets the number of idle connections
   */
  get idleCount() {
    return this.idleConnections.length;
  }
  /**
   * Gets the total number of connections in the pool
   */
  get totalCount() {
    return this.connections.length;
  }
  /**
   * Gets a client connection from the pool.
   * Note: You must call `.release()` when finished with the client connection object. That will release the connection back to the pool to be used by other requests.
   */
  async connect() {
    if (this.isEnding) {
      throw new PostgresPoolError("Cannot use pool after calling end() on the pool", "ERR_PG_CONNECT_POOL_ENDED");
    }
    const idleConnection = this.idleConnections.shift();
    if (idleConnection) {
      if (idleConnection.idleTimeoutTimer) {
        clearTimeout(idleConnection.idleTimeoutTimer);
      }
      this.emit("idleConnectionActivated");
      return idleConnection;
    }
    const id = uuid.v4();
    if (this.connections.length < this.options.poolSize) {
      this.connections.push(id);
      try {
        const connection = await this._createConnection(id);
        return connection;
      } catch (ex) {
        const connectionIndex = this.connections.indexOf(id);
        if (connectionIndex > -1) {
          this.connections.splice(connectionIndex, 1);
        }
        throw ex;
      }
    }
    this.emit("connectionRequestQueued");
    this.connectionQueue.push(id);
    let connectionTimeoutTimer = null;
    return await Promise.race([
      new Promise((resolve) => {
        this.connectionQueueEventEmitter.on(`connection_${id}`, (client) => {
          if (connectionTimeoutTimer) {
            clearTimeout(connectionTimeoutTimer);
          }
          this.connectionQueueEventEmitter.removeAllListeners(`connection_${id}`);
          this.emit("connectionRequestDequeued");
          resolve(client);
        });
      }),
      (async () => {
        connectionTimeoutTimer = await promises.setTimeout(this.options.waitForAvailableConnectionTimeoutMillis);
        this.connectionQueueEventEmitter.removeAllListeners(`connection_${id}`);
        const index = this.connectionQueue.indexOf(id);
        if (index > -1) {
          this.connectionQueue.splice(index, 1);
        }
        throw new PostgresPoolError("Timed out while waiting for available connection in pool", "ERR_PG_CONNECT_POOL_CONNECTION_TIMEOUT");
      })()
    ]);
  }
  /**
   * Gets a connection to the database and executes the specified query. This method will release the connection back to the pool when the query has finished.
   * @param {string} text
   * @param {object | object[]} values - If an object, keys represent named parameters in the query
   */
  query(text, values) {
    if (Array.isArray(values)) {
      return this._query(text, values);
    }
    if (!values || !Object.keys(values).length) {
      return this._query(text);
    }
    const tokenMatches = text.match(this.options.namedParameterFindRegExp);
    if (!tokenMatches) {
      throw new PostgresPoolError("Did not find named parameters in in the query. Expected named parameter form is @foo", "ERR_PG_QUERY_NO_NAMED_PARAMETERS");
    }
    const tokens = Array.from(new Set(tokenMatches.map(this.options.getNamedParameterName)));
    const missingParameters = [];
    for (const token of tokens) {
      if (!(token in values)) {
        missingParameters.push(token);
      }
    }
    if (missingParameters.length) {
      throw new PostgresPoolError(`Missing query parameter(s): ${missingParameters.join(", ")}`, "ERR_PG_QUERY_MISSING_QUERY_PARAMETER");
    }
    let sql = text.slice();
    const params = [];
    let tokenIndex = 1;
    for (const token of tokens) {
      sql = sql.replace(this.options.getNamedParameterReplaceRegExp(token), `$${tokenIndex}`);
      params.push(values[token]);
      tokenIndex += 1;
    }
    return this._query(sql, params);
  }
  /**
   * Drains the pool of all active client connections and prevents additional connections
   */
  end() {
    this.isEnding = true;
    return this.drainIdleConnections();
  }
  /**
   * Drains the pool of all idle client connections.
   */
  async drainIdleConnections() {
    await Promise.all([...this.idleConnections].map((idleConnection) => this._removeConnection(idleConnection)));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async _query(text, values, reconnectQueryStartTime) {
    const connection = await this.connect();
    let removeConnection = false;
    let timeoutError;
    let connectionError;
    try {
      const results2 = await connection.query(text, values);
      return results2;
    } catch (ex) {
      const { message } = ex;
      if (this.options.reconnectOnReadOnlyTransactionError && /cannot execute [\s\w]+ in a read-only transaction/giu.test(message)) {
        timeoutError = ex;
        removeConnection = true;
      } else if (this.options.reconnectOnConnectionError && /Client has encountered a connection error and is not queryable/giu.test(message)) {
        connectionError = ex;
        removeConnection = true;
      } else {
        throw ex;
      }
    } finally {
      await connection.release(removeConnection);
    }
    if (timeoutError) {
      this.emit("queryDeniedForReadOnlyTransaction");
    } else if (connectionError) {
      this.emit("queryDeniedForConnectionError");
    }
    await this.drainIdleConnections();
    if (!reconnectQueryStartTime) {
      reconnectQueryStartTime = process.hrtime();
    }
    if (timeoutError && this.options.waitForReconnectReadOnlyTransactionMillis > 0) {
      await promises.setTimeout(this.options.waitForReconnectReadOnlyTransactionMillis);
    }
    if (connectionError && this.options.waitForReconnectConnectionMillis > 0) {
      await promises.setTimeout(this.options.waitForReconnectConnectionMillis);
    }
    const diff = process.hrtime(reconnectQueryStartTime);
    const timeSinceLastRun = Number((diff[0] * 1e3 + diff[1] * 1e-6).toFixed(3));
    if (timeoutError && timeSinceLastRun > this.options.readOnlyTransactionReconnectTimeoutMillis) {
      throw timeoutError;
    }
    if (connectionError && timeSinceLastRun > this.options.connectionReconnectTimeoutMillis) {
      throw connectionError;
    }
    const results = await this._query(text, values, reconnectQueryStartTime);
    return results;
  }
  /**
   * Creates a new client connection to add to the pool
   * @param {string} connectionId
   * @param {number} [retryAttempt=0]
   * @param {bigint} [createConnectionStartTime] - High-resolution time (in nanoseconds) for when the connection was created
   * @param {[number,number]} [databaseStartupStartTime] - hrtime when the db was first listed as starting up
   */
  async _createConnection(connectionId, retryAttempt = 0, createConnectionStartTime = process.hrtime.bigint(), databaseStartupStartTime) {
    const client = new pg__default.Client(this.options);
    client.uniqueId = connectionId;
    client.release = async (removeConnection = false) => {
      if (this.isEnding || removeConnection) {
        await this._removeConnection(client);
        return;
      }
      const id = this.connectionQueue.shift();
      if (id) {
        this.connectionQueueEventEmitter.emit(`connection_${id}`, client);
      } else if (this.options.idleTimeoutMillis > 0) {
        client.idleTimeoutTimer = setTimeout(() => {
          void this._removeConnection(client);
        }, this.options.idleTimeoutMillis);
        this.idleConnections.push(client);
        this.emit("connectionIdle");
      } else {
        await this._removeConnection(client);
      }
    };
    client.errorHandler = (err) => {
      void this._removeConnection(client).finally(() => this.emit("error", err, client));
    };
    client.on("error", client.errorHandler);
    let connectionTimeoutTimer = null;
    const { connectionTimeoutMillis } = this.options;
    try {
      await Promise.race([
        async function connectClient() {
          try {
            await client.connect();
          } finally {
            if (connectionTimeoutTimer) {
              clearTimeout(connectionTimeoutTimer);
            }
          }
        }(),
        async function connectTimeout() {
          connectionTimeoutTimer = await promises.setTimeout(connectionTimeoutMillis);
          throw new PostgresPoolError("Timed out trying to connect to postgres", "ERR_PG_CONNECT_TIMEOUT");
        }()
      ]);
      this.emit("connectionAddedToPool", {
        connectionId,
        retryAttempt,
        startTime: createConnectionStartTime
      });
    } catch (ex) {
      const { connection } = client;
      if (connection) {
        connection.stream.destroy();
      }
      await client.end();
      const { message, code } = ex;
      let retryConnection = false;
      if (this.options.retryConnectionMaxRetries) {
        if (code) {
          retryConnection = this.options.retryConnectionErrorCodes.includes(code);
        } else {
          for (const errorCode of this.options.retryConnectionErrorCodes) {
            if (message.includes(errorCode)) {
              retryConnection = true;
              break;
            }
          }
        }
      }
      if (retryConnection && retryAttempt < this.options.retryConnectionMaxRetries) {
        this.emit("retryConnectionOnError");
        if (this.options.retryConnectionWaitMillis > 0) {
          await promises.setTimeout(this.options.retryConnectionWaitMillis);
        }
        const connectionAfterRetry = await this._createConnection(connectionId, retryAttempt + 1, createConnectionStartTime, databaseStartupStartTime);
        return connectionAfterRetry;
      }
      if (this.options.reconnectOnDatabaseIsStartingError && /the database system is starting up/giu.test(message)) {
        this.emit("waitingForDatabaseToStart");
        if (!databaseStartupStartTime) {
          databaseStartupStartTime = process.hrtime();
        }
        if (this.options.waitForDatabaseStartupMillis > 0) {
          await promises.setTimeout(this.options.waitForDatabaseStartupMillis);
        }
        const diff = process.hrtime(databaseStartupStartTime);
        const timeSinceFirstConnectAttempt = Number((diff[0] * 1e3 + diff[1] * 1e-6).toFixed(3));
        if (timeSinceFirstConnectAttempt > this.options.databaseStartupTimeoutMillis) {
          throw ex;
        }
        const connectionAfterRetry = await this._createConnection(connectionId, 0, createConnectionStartTime, databaseStartupStartTime);
        return connectionAfterRetry;
      }
      throw ex;
    }
    return client;
  }
  /**
   * Removes the client connection from the pool and tries to gracefully shut it down
   * @param {PoolClient} client
   */
  async _removeConnection(client) {
    client.removeListener("error", client.errorHandler);
    client.on("error", () => {
    });
    if (client.idleTimeoutTimer) {
      clearTimeout(client.idleTimeoutTimer);
    }
    const idleConnectionIndex = this.idleConnections.findIndex((connection) => connection.uniqueId === client.uniqueId);
    if (idleConnectionIndex > -1) {
      this.idleConnections.splice(idleConnectionIndex, 1);
      this.emit("connectionRemovedFromIdlePool");
    }
    const connectionIndex = this.connections.indexOf(client.uniqueId);
    if (connectionIndex > -1) {
      this.connections.splice(connectionIndex, 1);
    }
    try {
      await client.end();
    } catch (ex) {
      const { message } = ex;
      if (!/This socket has been ended by the other party/giu.test(message)) {
        this.emit("error", ex);
      }
    }
    this.emit("connectionRemovedFromPool");
  }
}

exports.Pool = Pool;
exports.PostgresPoolError = PostgresPoolError;
